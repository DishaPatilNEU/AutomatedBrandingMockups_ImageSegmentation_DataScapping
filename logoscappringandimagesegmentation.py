# -*- coding: utf-8 -*-
"""LogoScappringAndImageSegmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mOSKiHk2bcrKxldfd_NdmTQ9NAPTEdxE
"""

!pip install flask pyngrok
!pip install cairosvg
!ngrok authtoken 2yKQ5Dx3W6UxR8pq1mGXuYU96t3_4h1JB19VykJcXj7xKt9eE

!pip install segmentation_models_pytorch

pip install labelme

from flask import Flask, request, render_template_string, send_from_directory
from pyngrok import ngrok
import os
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from PIL import Image as PILImage, Image, ImageEnhance
from io import BytesIO
import cairosvg
import torch
import pickle
import numpy as np
import cv2
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
!ngrok authtoken 2yKQ5Dx3W6UxR8pq1mGXuYU96t3_4h1JB19VykJcXj7xKt9eE
# === Flask App Setup ===
app = Flask(__name__)
LOGO_FOLDER = "/content/drive/MyDrive/LogoPlacement"
os.makedirs(LOGO_FOLDER, exist_ok=True)

# === Device Setup ===
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# === Load Shirt Model ===
MODEL_PATH = os.path.join(LOGO_FOLDER, "model_pickle.pkl")
with open(MODEL_PATH, 'rb') as f:
    loaded_model = pickle.load(f)
loaded_model.to(device)
loaded_model.eval()

# === Load Cup Model ===
CUP_MODEL_PATH = os.path.join(LOGO_FOLDER, "cup_pickel_model.pkl")
with open(CUP_MODEL_PATH, 'rb') as f:
    cup_loaded_model = pickle.load(f)
cup_loaded_model.to(device)
cup_loaded_model.eval()

# === Load Book Model ===
BOOK_MODEL_PATH = os.path.join(LOGO_FOLDER, "book_model_pickle.pkl")
with open(BOOK_MODEL_PATH, 'rb') as f:
    book_loaded_model = pickle.load(f)
book_loaded_model.to(device)
book_loaded_model.eval()

# === Load Bottle Model ===
BOTTLE_MODEL_PATH = os.path.join(LOGO_FOLDER, "bottle_model_pickle.pkl")
with open(BOTTLE_MODEL_PATH, 'rb') as f:
    bottle_loaded_model = pickle.load(f)
bottle_loaded_model.to(device)
bottle_loaded_model.eval()

# === Load Keychain Model ===
KEYCHAIN_MODEL_PATH = os.path.join(LOGO_FOLDER, "keychain_model_pickle.pkl")
with open(KEYCHAIN_MODEL_PATH, 'rb') as f:
    keychain_loaded_model = pickle.load(f)
keychain_loaded_model.to(device)
keychain_loaded_model.eval()

# === Preprocess Function ===
def preprocess_image(img_path, size=(256, 256)):
    img = cv2.imread(img_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_resized = cv2.resize(img_rgb, size)
    img_norm = img_resized.astype('float32') / 255.0
    img_tensor = torch.tensor(img_norm).permute(2, 0, 1).unsqueeze(0)
    return img_tensor.to(device), img_resized

# --- Sharpen Logo (OpenCV Unsharp Mask + Pillow Sharpness) ---
def sharpen_logo(pil_img):
    img = np.array(pil_img)
    img = cv2.cvtColor(img, cv2.COLOR_RGBA2BGRA)
    blurred = cv2.GaussianBlur(img, (0, 0), 3)
    sharpened = cv2.addWeighted(img, 1.5, blurred, -0.5, 0)
    sharpened = cv2.cvtColor(sharpened, cv2.COLOR_BGRA2RGBA)
    pil_sharp = Image.fromarray(sharpened)
    enhancer = ImageEnhance.Sharpness(pil_sharp)
    return enhancer.enhance(2.0)

# === URL & Logo Helpers ===
def href_matches(href, base_url):
    if not href:
        return False
    href = href.strip()
    if href.startswith('#') and href not in ['#', '#home', '#HOME']:
        return False
    abs_href = urljoin(base_url + '/', href).rstrip('/')
    canonical = base_url.rstrip('/')
    common_home_paths = ['', '/', './', './index.html', 'index.html', '#']
    return href in common_home_paths or abs_href == canonical

def static_scrape_logos(url):
    headers = {"User-Agent": "Mozilla/5.0"}
    try:
        response = requests.get(url, headers=headers, timeout=10)
    except Exception as e:
        print(f"Error scraping URL {url}: {e}")
        return []
    if response.status_code != 200:
        print(f"Failed to fetch {url}, status code: {response.status_code}")
        return []
    soup = BeautifulSoup(response.text, 'html.parser')
    base_parsed = urlparse(url)
    base_root = f"{base_parsed.scheme}://{base_parsed.netloc}".rstrip('/')
    logo_set = []
    for a_tag in soup.find_all('a', href=True):
        href = a_tag.get('href')
        if not href_matches(href, base_root):
            continue
        for tag in a_tag.descendants:
            if tag.name == 'img' and tag.get('src'):
                img_url = urljoin(url, tag['src'])
                logo_set.append(img_url)
            elif tag.name == 'svg':
                logo_set.append(str(tag))
    return logo_set

def clearbit_logo_fallback(domain):
    clearbit_url = f"https://logo.clearbit.com/{domain}"
    try:
        response = requests.get(clearbit_url)
        if response.status_code == 200:
            return clearbit_url
        else:
            return None
    except Exception as e:
        print(f"Clearbit fallback failed for {domain}: {e}")
        return None

def save_logo(item, domain, index=1, size=(120, 120)):
    try:
        if item.strip().lower().endswith('.svg'):
            svg_path = f"{LOGO_FOLDER}/{domain}.logo{index}.svg"
            png_path = f"{LOGO_FOLDER}/{domain}.logo{index}.png"
            content = requests.get(item).text
            with open(svg_path, "w") as f:
                f.write(content)
            cairosvg.svg2png(bytestring=content.encode(), write_to=png_path, output_width=size[0], output_height=size[1])
            return png_path
        elif item.strip().startswith('<svg'):
            svg_path = f"{LOGO_FOLDER}/{domain}.logo{index}.inline.svg"
            png_path = f"{LOGO_FOLDER}/{domain}.logo{index}.inline.png"
            with open(svg_path, "w") as f:
                f.write(item)
            cairosvg.svg2png(bytestring=item.encode(), write_to=png_path, output_width=size[0], output_height=size[1])
            return png_path
        else:
            response = requests.get(item)
            img = PILImage.open(BytesIO(response.content)).convert("RGBA")
            img = img.resize(size, PILImage.Resampling.LANCZOS)
            png_path = f"{LOGO_FOLDER}/{domain}.logo{index}.png"
            img.save(png_path)
            return png_path
    except Exception as e:
        print(f"Error saving logo {item}: {e}")
        return None

def process_url(url):
    logos = static_scrape_logos(url)
    domain = urlparse(url).netloc.replace("www.", "")
    if not logos:
        fallback = clearbit_logo_fallback(domain)
        if fallback:
            logos = [fallback]
    for i, logo in enumerate(logos, start=1):
        logo_path = save_logo(logo, domain, i)
        if logo_path and logo_path.endswith(".png"):
            return logo_path
    return None

# === Logo Placement on Shirt ===
def apply_logo_on_shirt(image_path, logo_path):
    input_tensor, resized_img = preprocess_image(image_path)
    with torch.no_grad():
        pred_mask = loaded_model(input_tensor).squeeze().cpu().numpy()

    binary_mask = (pred_mask > 0.5).astype(np.uint8) * 255
    h, w = binary_mask.shape

    # Define the torso region (cropping sleeves)
    left, right = int(w * 0.25), int(w * 0.75)
    cropped_mask = np.zeros_like(binary_mask)
    cropped_mask[:, left:right] = binary_mask[:, left:right]

    ys, xs = np.where(cropped_mask == 255)

    if len(xs) == 0 or len(ys) == 0:
        print("No foreground pixels found in torso region for shirt. Skipping logo placement.")
        return [], None

    x_min, x_max = np.min(xs), np.max(xs)
    y_min, y_max = np.min(ys), np.max(ys)
    bbox_w, bbox_h = x_max - x_min, y_max - y_min

    # Find contours and centroid for placement
    contours, _ = cv2.findContours(cropped_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if not contours:
        print("No contours found in the cropped mask for shirt. Skipping logo placement.")
        return [], None

    largest_contour = max(contours, key=cv2.contourArea)
    M = cv2.moments(largest_contour)
    if M["m00"] != 0:
        centroid_x = int(M["m10"] / M["m00"])
        centroid_y = int(M["m01"] / M["m00"])
    else:
        # Fallback if moment calculation fails
        centroid_x, centroid_y = x_min + bbox_w // 2, y_min + bbox_h // 2

    logo = Image.open(logo_path).convert("RGBA")

    # Apply sharpening (using the sharpen_logo function you already have)
    logo_sharpened = sharpen_logo(logo)

    # Apply contrast enhancement
    contrast_enhancer = ImageEnhance.Contrast(logo_sharpened)
    logo_enhanced = contrast_enhancer.enhance(1.2) # Slightly increase contrast

    logo_ratio = logo_enhanced.width / logo_enhanced.height

    # === Center logo sizing ===
    center_scale_w = 0.6  # 60% of bbox width
    target_w_center = int(bbox_w * center_scale_w)
    target_h_center = int(target_w_center / logo_ratio)
    max_h_center = int(bbox_h * 0.5)  # max 50% height

    if target_h_center > max_h_center:
        target_h_center = max_h_center
        target_w_center = int(target_h_center * logo_ratio)

    # Ensure dimensions are positive
    target_w_center = max(1, target_w_center)
    target_h_center = max(1, target_h_center)

    logo_resized_center = logo_enhanced.resize((target_w_center, target_h_center), Image.LANCZOS)

    # === Side logos sizing ===
    side_scale_w = 0.4  # 40% of bbox width
    target_w_side = int(bbox_w * side_scale_w)
    target_h_side = int(target_w_side / logo_ratio)
    max_h_side = int(bbox_h * 0.4)  # max 40% height

    if target_h_side > max_h_side:
        target_h_side = max_h_side
        target_w_side = int(target_h_side * logo_ratio)

    # Ensure dimensions are positive
    target_w_side = max(1, target_w_side)
    target_h_side = max(1, target_h_side)

    logo_resized_side = logo_enhanced.resize((target_w_side, target_h_side), Image.LANCZOS)

    # === Prepare images for placement ===
    shirt_base_img = Image.fromarray(resized_img).convert("RGBA")

    # Variants to store results for PDF
    shirt_variants = []

    # === Center chest placement (20% above centroid) ===
    vertical_offset_center = int(0.2 * bbox_h)
    x_c = centroid_x - logo_resized_center.width // 2
    y_c = centroid_y - logo_resized_center.height // 2 - vertical_offset_center
    y_c = max(y_min, y_c) # Clamp y_c to ensure it's not above the image or too high in bbox

    shirt_center_img = shirt_base_img.copy()
    shirt_center_img.paste(logo_resized_center, (x_c, y_c), logo_resized_center)
    shirt_variants.append({"image": shirt_center_img, "title": "Center Chest"})

    # === Left chest placement (10% from left bbox, 20% down from y_min) ===
    x_l = x_min + int(0.1 * bbox_w)
    y_l = y_min + int(0.2 * bbox_h)
    shirt_left_img = shirt_base_img.copy()
    shirt_left_img.paste(logo_resized_side, (x_l, y_l), logo_resized_side)
    shirt_variants.append({"image": shirt_left_img, "title": "Left Chest"})

    # === Right chest placement (10% from right bbox, 20% down from y_min) ===
    x_r = x_max - int(0.1 * bbox_w) - logo_resized_side.width
    y_r = y_min + int(0.2 * bbox_h)
    shirt_right_img = shirt_base_img.copy()
    shirt_right_img.paste(logo_resized_side, (x_r, y_r), logo_resized_side)
    shirt_variants.append({"image": shirt_right_img, "title": "Right Chest"})

    paths = []
    pdf_path = os.path.join(LOGO_FOLDER, "shirt_logo_placements.pdf")

    with PdfPages(pdf_path) as pdf:
        for i, variant_data in enumerate(shirt_variants, 1):
            img = variant_data["image"]
            title = variant_data["title"]
            out_path = f"{LOGO_FOLDER}/shirt_placed_logo_{i}.png"
            img.save(out_path)
            paths.append(out_path)

            fig = plt.figure(figsize=(8, 10)) # Adjust figure size for better PDF display
            plt.imshow(img)
            plt.title(f"Shirt Logo: {title}")
            plt.axis("off")
            pdf.savefig(fig)
            plt.close()

    print(f"✅ Saved shirt logo placements PDF at: {pdf_path}")
    return paths, pdf_path

# === Logo Placement on Cup ===
def apply_logo_on_cup(image_path, logo_path):
    input_tensor, resized_img = preprocess_image(image_path)
    with torch.no_grad():
        pred_mask = cup_loaded_model(input_tensor).squeeze().cpu().numpy()
    binary_mask = (pred_mask > 0.5).astype(np.uint8) * 255
    h, w = binary_mask.shape
    left, right = int(w * 0.20), int(w * 0.70)
    cropped_mask = np.zeros_like(binary_mask)
    cropped_mask[:, left:right] = binary_mask[:, left:right]

    ys, xs = np.where(cropped_mask == 255)
    if not xs.size or not ys.size:
        print("No foreground pixels found in cup region. Skipping logo placement.")
        return [], None

    x_min, x_max = np.min(xs), np.max(xs)
    y_min, y_max = np.min(ys), np.max(ys)
    bbox_w, bbox_h = x_max - x_min, y_max - y_min

    contours, _ = cv2.findContours(cropped_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        print("No contours found in the cropped mask for cup. Skipping logo placement.")
        return [], None

    largest_contour = max(contours, key=cv2.contourArea)
    M = cv2.moments(largest_contour)
    if M["m00"] != 0:
        centroid_x = int(M["m10"] / M["m00"])
        centroid_y = int(M["m01"] / M["m00"])
    else:
        centroid_x, centroid_y = x_min + bbox_w // 2, y_min + bbox_h // 2

    logo = Image.open(logo_path).convert("RGBA")
    logo_sharpened = sharpen_logo(logo) # Apply sharpening
    logo_ratio = logo_sharpened.width / logo_sharpened.height

    target_w = int(bbox_w * 0.6)
    target_h = int(target_w / logo_ratio)
    if target_h > bbox_h * 0.5:
        target_h = int(bbox_h * 0.5)
        target_w = int(target_h * logo_ratio)

    target_w = max(1, target_w)
    target_h = max(1, target_h)

    logo_resized = logo_sharpened.resize((target_w, target_h), Image.LANCZOS)

    cup_base_img = Image.fromarray(resized_img).convert("RGBA")

    cup_variants = []
    y_offsets_pixels = [0, -int(0.20 * bbox_h), int(0.28 * bbox_h)]
    titles = ["Center", "Upper", "Lower"]

    for i, offset in enumerate(y_offsets_pixels):
        cup_variant = cup_base_img.copy()
        x_logo = centroid_x - target_w // 2
        y_logo = centroid_y - target_h // 2 + offset

        # Clamp y_logo to stay within reasonable bounds (e.g., within bbox)
        y_logo = max(y_min, min(y_logo, y_max - target_h))

        cup_variant.paste(logo_resized, (x_logo, y_logo), logo_resized)
        cup_variants.append({"image": cup_variant, "title": titles[i]})

    paths = []
    pdf_path = os.path.join(LOGO_FOLDER, "cup_logo_placements.pdf")

    with PdfPages(pdf_path) as pdf:
        for i, variant_data in enumerate(cup_variants, 1):
            img = variant_data["image"]
            title = variant_data["title"]
            out_path = f"{LOGO_FOLDER}/cup_placed_logo_{i}.png"
            img.save(out_path)
            paths.append(out_path)

            fig = plt.figure(figsize=(8, 10)) # Adjust figure size for better PDF display
            plt.imshow(img)
            plt.title(f"Cup Logo: {title}")
            plt.axis("off")
            pdf.savefig(fig)
            plt.close()

    print(f"✅ Saved cup logo placements PDF at: {pdf_path}")
    return paths, pdf_path

# === Logo Placement on Book ===
def apply_logo_on_book(image_path, logo_path):
    input_tensor, resized_img = preprocess_image(image_path)
    with torch.no_grad():
        pred_mask = book_loaded_model(input_tensor).squeeze().cpu().numpy()

    binary_mask = (pred_mask > 0.5).astype(np.uint8) * 255
    h, w = binary_mask.shape

    # Define the region of interest for the book (similar to cropping sleeves for shirt)
    left, right = int(w * 0.25), int(w * 0.75)
    cropped_mask = np.zeros_like(binary_mask)
    cropped_mask[:, left:right] = binary_mask[:, left:right]

    ys, xs = np.where(cropped_mask == 255)

    if len(xs) == 0 or len(ys) == 0:
        print("No foreground pixels found in the book region. Skipping logo placement.")
        return [], None

    x_min, x_max = np.min(xs), np.max(xs)
    y_min, y_max = np.min(ys), np.max(ys)
    bbox_w, bbox_h = x_max - x_min, y_max - y_min

    contours, _ = cv2.findContours(cropped_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if not contours:
        print("No contours found in the cropped mask for book. Skipping logo placement.")
        return [], None

    largest_contour = max(contours, key=cv2.contourArea)
    M = cv2.moments(largest_contour)
    if M["m00"] != 0:
        centroid_x = int(M["m10"] / M["m00"])
        centroid_y = int(M["m01"] / M["m00"])
    else:
        # Fallback if moment calculation fails
        centroid_x, centroid_y = x_min + bbox_w // 2, y_min + bbox_h // 2

    logo = Image.open(logo_path).convert("RGBA")
    logo_sharpened = sharpen_logo(logo) # Apply sharpening
    logo_ratio = logo_sharpened.width / logo_sharpened.height
    base_img = Image.fromarray(resized_img).convert("RGBA")

    book_variants = []
    # Define positions and corresponding width scales
    positions_and_scales = [
        ("Center", 0.7),  # Center logo is larger (70% of bbox width)
        ("Up More", 0.4), # Up logo is smaller (40% of bbox width)
        ("Down More", 0.4) # Down logo is smaller (40% of bbox width)
    ]

    for idx, (pos_name, scale) in enumerate(positions_and_scales):
        # Resize logo based on the current scale
        target_w = int(bbox_w * scale)
        target_h = int(target_w / logo_ratio)

        # Ensure logo doesn't exceed a maximum height (e.g., 50% of bbox height)
        if target_h > bbox_h * 0.5:
            target_h = int(bbox_h * 0.5)
            target_w = int(target_h * logo_ratio)

        # Ensure dimensions are positive
        target_w = max(1, target_w)
        target_h = max(1, target_h)

        logo_resized = logo_sharpened.resize((target_w, target_h), Image.LANCZOS)

        # Calculate positions based on the current variant
        x_logo = centroid_x - target_w // 2 # X position is always centered

        if pos_name == "Center":
            y_logo = centroid_y - target_h // 2
        elif pos_name == "Up More":
            y_logo = y_min + int(0.1 * bbox_h) # 10% from top of bbox
        elif pos_name == "Down More":
            y_logo = centroid_y - target_h // 2 + int(0.25 * bbox_h) # 25% below centroid

        # Create a copy for each variant and paste the logo
        book_variant = base_img.copy()
        book_variant.paste(logo_resized, (x_logo, y_logo), logo_resized)
        book_variants.append({"image": book_variant, "title": pos_name})

    # Save images and generate PDF
    paths = []
    pdf_path = os.path.join(LOGO_FOLDER, "book_logo_placements.pdf")
    with PdfPages(pdf_path) as pdf:
        for i, variant_data in enumerate(book_variants, 1):
            img = variant_data["image"]
            title = variant_data["title"]
            out_path = f"{LOGO_FOLDER}/book_placed_logo_{i}.png"
            img.save(out_path)
            paths.append(out_path)

            fig = plt.figure(figsize=(8, 10)) # Adjust figure size for better PDF display
            plt.imshow(img)
            plt.title(f"Book Logo: {title}")
            plt.axis("off")
            pdf.savefig(fig)
            plt.close()

    print(f"✅ Saved book logo placement PDF at: {pdf_path}")
    return paths, pdf_path

# === Logo Placement on Bottle ===
def apply_logo_on_bottle(image_path, logo_path):
    input_tensor, resized_img = preprocess_image(image_path)
    with torch.no_grad():
        pred_mask = bottle_loaded_model(input_tensor).squeeze().cpu().numpy()
    binary_mask = (pred_mask > 0.5).astype(np.uint8) # No need for * 255 initially if using np.where

    ys, xs = np.where(binary_mask == 1)
    if not xs.size or not ys.size: # Handle cases where no mask is found
        print("No bottle mask detected, cannot place logo.")
        return [], None

    x_min, x_max = np.min(xs), np.max(xs)
    y_min, y_max = np.min(ys), np.max(ys)
    bbox_w, bbox_h = x_max - x_min, y_max - y_min

    # Ensure binary_mask is 255 for findContours if it was 0/1 before
    binary_mask_for_contours = binary_mask * 255
    contours, _ = cv2.findContours(binary_mask_for_contours, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        M = cv2.moments(largest_contour)
        if M["m00"] != 0:
            center_x = int(M["m10"] / M["m00"])
            center_y = int(M["m01"] / M["m00"])
        else:
            center_x = x_min + bbox_w // 2
            center_y = y_min + bbox_h // 2
    else:
        # Fallback if no contours are found despite having pixels (very unlikely with np.where)
        center_x = x_min + bbox_w // 2
        center_y = y_min + bbox_h // 2


    logo = Image.open(logo_path).convert("RGBA")
    logo_sharpened = sharpen_logo(logo) # Apply sharpening

    bottle_base_img = Image.fromarray(resized_img).convert("RGBA")
    bottle_variants = []

    # --- Horizontal Logo Placement ---
    h_logo_ratio = logo_sharpened.width / logo_sharpened.height

    desired_h_width_ratio = 0.6
    desired_h_height_ratio = 0.4

    tentative_h_w = int(bbox_w * desired_h_width_ratio)
    tentative_h_h = int(tentative_h_w / h_logo_ratio)

    if tentative_h_h > bbox_h * desired_h_height_ratio:
        h_target_h = int(bbox_h * desired_h_height_ratio)
        h_target_w = int(h_target_h * h_logo_ratio)
    elif tentative_h_w < bbox_w * 0.2 and bbox_w * 0.2 > 0: # Ensure minimum is positive
        h_target_w = int(bbox_w * 0.2)
        h_target_h = int(h_target_w / h_logo_ratio)
    else:
        h_target_w = tentative_h_w
        h_target_h = tentative_h_h

    h_target_w = max(1, h_target_w)
    h_target_h = max(1, h_target_h)

    logo_h_resized = logo_sharpened.resize((h_target_w, h_target_h), Image.LANCZOS)
    logo_h_x = center_x - logo_h_resized.width // 2
    logo_h_y = center_y - logo_h_resized.height // 2

    horizontal_img_variant = bottle_base_img.copy()
    horizontal_img_variant.paste(logo_h_resized, (logo_h_x, logo_h_y), logo_h_resized)
    bottle_variants.append({"image": horizontal_img_variant, "title": "Horizontal"})

    # --- Vertical Logo Placement with updated aspect ratio logic ---
    logo_rotated = logo_sharpened.rotate(90, expand=True) # Rotate the logo
    v_logo_w, v_logo_h = logo_rotated.size
    v_logo_ratio = v_logo_w / v_logo_h

    # Define a small tolerance for "square-ish"
    square_tolerance = 0.1

    if abs(v_logo_w - v_logo_h) / max(v_logo_w, v_logo_h) < square_tolerance:
        # If the rotated logo is close to square
        max_height = int(bbox_h * 0.3)  # 30% of bottle height for near-square
        target_v_w = int(max_height * v_logo_ratio)
        target_v_h = max_height
    else:
        # If the rotated logo is rectangular (not square-ish)
        max_width = int(bbox_w * 0.6)  # Up to 60% of bottle's width (rotated)
        target_v_h = int(max_width / v_logo_ratio)
        target_v_w = max_width

        if target_v_h > bbox_h * 0.7: # Example: max 70% of bottle height
            target_v_h = int(bbox_h * 0.7)
            target_v_w = int(target_v_h * v_logo_ratio) # Recalculate width

    # Ensure final dimensions are at least 1x1 pixel and positive
    v_target_w = max(1, int(target_v_w))
    v_target_h = max(1, int(target_v_h))

    logo_v_resized = logo_rotated.resize((v_target_w, v_target_h), Image.LANCZOS)
    logo_v_x = center_x - logo_v_resized.width // 2
    logo_v_y = center_y - logo_v_resized.height // 2

    vertical_img_variant = bottle_base_img.copy()
    vertical_img_variant.paste(logo_v_resized, (logo_v_x, logo_v_y), logo_v_resized)
    bottle_variants.append({"image": vertical_img_variant, "title": "Vertical"})

    paths = []
    pdf_path = os.path.join(LOGO_FOLDER, "bottle_logo_placements.pdf")

    with PdfPages(pdf_path) as pdf:
        for i, variant_data in enumerate(bottle_variants, 1):
            img = variant_data["image"]
            title = variant_data["title"]
            out_path = f"{LOGO_FOLDER}/bottle_placed_logo_{i}.png"
            img.save(out_path)
            paths.append(out_path)

            fig = plt.figure(figsize=(8, 10)) # Adjust figure size for better PDF display
            plt.imshow(img)
            plt.title(f"Bottle Logo: {title}")
            plt.axis("off")
            pdf.savefig(fig)
            plt.close()

    print(f"✅ Saved bottle logo placements PDF at: {pdf_path}")
    return paths, pdf_path

# === Logo Placement on Keychain ===
def apply_logo_on_keychain(image_path, logo_path):
    input_tensor, resized_img = preprocess_image(image_path)
    with torch.no_grad():
        pred_mask = keychain_loaded_model(input_tensor).squeeze().cpu().numpy()

    binary_mask = (pred_mask > 0.5).astype(np.uint8) * 255
    h, w = binary_mask.shape
    left, right = int(w * 0.40), int(w * 0.70)
    cropped_mask = np.zeros_like(binary_mask)
    cropped_mask[:, left:right] = binary_mask[:, left:right]

    ys, xs = np.where(cropped_mask == 255)
    if not xs.size or not ys.size:
        print("No foreground pixels found in keychain region. Skipping logo placement.")
        return [], None

    x_min, x_max = np.min(xs), np.max(xs)
    y_min, y_max = np.min(ys), np.max(ys)
    bbox_w, bbox_h = x_max - x_min, y_max - y_min

    contours, _ = cv2.findContours(cropped_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        print("No contours found in the cropped mask for keychain. Skipping logo placement.")
        return [], None

    largest_contour = max(contours, key=cv2.contourArea)
    M = cv2.moments(largest_contour)
    if M["m00"] != 0:
        centroid_x = int(M["m10"] / M["m00"])
        centroid_y = int(M["m01"] / M["m00"])
    else:
        centroid_x, centroid_y = x_min + bbox_w // 2, y_min + bbox_h // 2

    logo = Image.open(logo_path).convert("RGBA")
    logo_sharpened = sharpen_logo(logo) # Apply sharpening
    logo_ratio = logo_sharpened.width / logo_sharpened.height

    target_w = int(bbox_w * 0.8) # Adjusted for keychain size
    target_h = int(target_w / logo_ratio)
    if target_h > bbox_h * 0.5:
        target_h = int(bbox_h * 0.5)
        target_w = int(target_h * logo_ratio)

    target_w = max(1, target_w)
    target_h = max(1, target_h)

    logo_resized = logo_sharpened.resize((target_w, target_h), Image.LANCZOS)

    base_img = Image.fromarray(resized_img).convert("RGBA")

    keychain_variants = []
    y_offsets_pixels = [0, -int(0.25 * bbox_h), int(0.31 * bbox_h)]
    titles = ["Center", "Upper", "Lower"]

    for i, offset in enumerate(y_offsets_pixels):
        keychain_variant = base_img.copy()
        x_logo = centroid_x - target_w // 2
        y_logo = centroid_y - target_h // 2 + offset

        # Clamp y_logo to stay within reasonable bounds
        y_logo = max(y_min, min(y_logo, y_max - target_h))

        keychain_variant.paste(logo_resized, (x_logo, y_logo), logo_resized)
        keychain_variants.append({"image": keychain_variant, "title": titles[i]})

    paths = []
    pdf_path = os.path.join(LOGO_FOLDER, "keychain_logo_placements.pdf")

    with PdfPages(pdf_path) as pdf:
        for i, variant_data in enumerate(keychain_variants, 1):
            img = variant_data["image"]
            title = variant_data["title"]
            out_path = f"{LOGO_FOLDER}/keychain_placed_logo_{i}.png"
            img.save(out_path)
            paths.append(out_path)

            fig = plt.figure(figsize=(8, 10)) # Adjust figure size for better PDF display
            plt.imshow(img)
            plt.title(f"Keychain Logo: {title}")
            plt.axis("off")
            pdf.savefig(fig)
            plt.close()

    print(f"✅ Saved keychain logo placements PDF at: {pdf_path}")
    return paths, pdf_path


# === Main Page ===
@app.route("/", methods=["GET", "POST"])
def home():
    submitted_url = None
    all_image_paths = []

    shirt_pdf_path = None
    cup_pdf_path = None
    book_pdf_path = None
    bottle_pdf_path = None
    keychain_pdf_path = None

    if request.method == "POST":
        submitted_url = request.form.get("url_input")
        if submitted_url:
            logo_path = process_url(submitted_url)
            if logo_path:
                # Shirt
                shirt_test_img = os.path.join(LOGO_FOLDER, "TestImage.png")
                shirt_image_paths, shirt_pdf_path = apply_logo_on_shirt(shirt_test_img, logo_path)
                all_image_paths.extend(shirt_image_paths)

                # Cup
                cup_test_img = os.path.join(LOGO_FOLDER, "TestImage_Cup.png")
                cup_image_paths, cup_pdf_path = apply_logo_on_cup(cup_test_img, logo_path)
                all_image_paths.extend(cup_image_paths)

                # Book
                book_test_img = os.path.join(LOGO_FOLDER, "TestImage_Book.png")
                book_image_paths, book_pdf_path = apply_logo_on_book(book_test_img, logo_path)
                all_image_paths.extend(book_image_paths)

                # Bottle
                bottle_test_img = os.path.join(LOGO_FOLDER, "TestBottle3.JPG")
                bottle_image_paths, bottle_pdf_path = apply_logo_on_bottle(bottle_test_img, logo_path)
                all_image_paths.extend(bottle_image_paths)

                # Keychain
                keychain_test_img = os.path.join(LOGO_FOLDER, "TestImage_Keychain.png")
                keychain_image_paths, keychain_pdf_path = apply_logo_on_keychain(keychain_test_img, logo_path)
                all_image_paths.extend(keychain_image_paths)

    return render_template_string("""
        <html>
        <head>
            <title>Logo Placement App</title>
            <style>
              body { font-family: sans-serif; margin: 20px; background-color: #f8f8f8; color: #333; }
              h2, h3 { color: #0056b3; }
              form { margin-bottom: 30px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; gap: 10px; align-items: center; }
              input[type="text"] { flex-grow: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
              input[type="submit"] { padding: 10px 20px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
              input[type="submit"]:hover { background-color: #218838; }
              .image-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Responsive grid */
                gap: 15px;
                max-width: 1300px;
                margin: 20px auto 40px;
              }
              .image-box {
                background-color: #f2f2f2;
                padding: 12px;
                border-radius: 10px;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: hidden; /* Ensure image doesn't break layout */
              }
              .image-box img {
                max-width: 100%;
                height: auto;
                object-fit: contain;
                border-radius: 6px;
                display: block;
                background-color: white;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
              }
              .image-box img:hover {
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
                transform: scale(1.02);
              }
              .pdf-links {
                margin-top: 30px;
                background-color: #e9f7ef;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
              }
              .pdf-links p { margin: 10px 0; }
              .pdf-links a { color: #007bff; text-decoration: none; font-weight: bold; }
              .pdf-links a:hover { text-decoration: underline; }
            </style>
        </head>
        <body>
            <h2>Logo Placement App</h2>
            <form method="post">
                <input type="text" name="url_input" placeholder="https://example.com" value="{{ submitted_url or '' }}" required>
                <input type="submit" value="Place Logo">
            </form>

            {% if submitted_url %}
              <h3>Results for: {{ submitted_url }}</h3>
              <div class="image-grid">
                {% for path in all_image_paths %}
                  <div class="image-box">
                    <img src="/images/{{ path.split('/')[-1] }}" alt="Logo placement">
                  </div>
                {% endfor %}
              </div>

              <div class="pdf-links">
                <h3>Download PDFs:</h3>
                {% if shirt_pdf_path %}
                  <p>Shirt Logo Placements: <a href="/images/{{ shirt_pdf_path.split('/')[-1] }}" target="_blank">View PDF</a></p>
                {% endif %}
                {% if cup_pdf_path %}
                  <p>Cup Logo Placements: <a href="/images/{{ cup_pdf_path.split('/')[-1] }}" target="_blank">View PDF</a></p>
                {% endif %}
                {% if book_pdf_path %}
                  <p>Book Logo Placements: <a href="/images/{{ book_pdf_path.split('/')[-1] }}" target="_blank">View PDF</a></p>
                {% endif %}
                {% if bottle_pdf_path %}
                  <p>Bottle Logo Placements: <a href="/images/{{ bottle_pdf_path.split('/')[-1] }}" target="_blank">View PDF</a></p>
                {% endif %}
                {% if keychain_pdf_path %}
                  <p>Keychain Logo Placements: <a href="/images/{{ keychain_pdf_path.split('/')[-1] }}" target="_blank">View PDF</a></p>
                {% endif %}
              </div>
            {% endif %}
        </body>
        </html>
    """,
    submitted_url=submitted_url,
    all_image_paths=all_image_paths,
    shirt_pdf_path=shirt_pdf_path,
    cup_pdf_path=cup_pdf_path,
    book_pdf_path=book_pdf_path,
    bottle_pdf_path=bottle_pdf_path,
    keychain_pdf_path=keychain_pdf_path
    )

# === Serve Images and PDFs ===
@app.route("/images/<filename>")
def serve_image(filename):
    return send_from_directory(LOGO_FOLDER, filename)

# === Run Server with ngrok ===
if __name__ == "__main__":
    public_url = ngrok.connect(5000)
    print(f" * ngrok public URL: {public_url}")
    app.run(port=5000)

